# TodoMVC
照着vue官方的TodoMVC（也就是尤大写的）示例写的。这里写出一些，在照写的过程中学到的东西。
## `<section>`
`<section>`这个标签功能上和`<div>`是一样的，但语义不同。`<section>`更多指的是文本类内容。所以为了更符合语义化的要求，在html结构中用`<section>`来当容器更好。
## `<footer>`和`<header>`
`<footer>`也就是页脚，同样是为了更好的语义化。
**别啥都`<div>`**
## `<script>`
```js
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```
这句话得单独写出来，js代码要在下面另写一个`<script>`标签（我怎么连这都不知道）
## `JSON.parse()`
可以把JSON字符串转换成对象
## `JSON.stringify()`
把对象或数组转换成JSON字符串
## `localStorage`
localStorage和sessionStorage属性允许在**浏览器**中储存key/value对的数据  
```js
//保存数据
localStorage.setItem("key","value");
//获得数据
localStorage.getItem("key");
//删除数据
localStorage.removeItem("key");
```
## `hashchange`
当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)
## 对象[]
除了用`object.key`可以拿到属性值，还可用`object['key']`
## `location.hash`
hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）
## `replace()`
简单说就是替换，前面放被替换的，后面放想替换的。被替换的可以用正则表达式
## 功能1：添加todo
localStorage用于长久保存整个网站的数据，保存的数据没有过期的时间，知道手动去删除。就像是一个网页的存档一样。  
用localStorage就可以保存之前输入的todo，即使关掉网页也不会消失。Cookie Clicker就用了localStorage，里面放的是一长串的“密码”，也是你当前的存档。  
这里用localStorage来作为所有的todo的第一个暂存地
```js
var STORAGE_KEY = "todos-vuejs-2.0";//设置Storage中的每一项属性名
var todoStorage = {
	fetch: function () {
		//用getItem拿到每一项数据，再用JSON.parse从字符串变成数组
		var todos = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
		//遍历拿到的数组，并未每一项添加一个id，数值为其再数组中的索引
		todos.forEach(function(todo, index) {
			todo.id = index;
		});
		todoStorage.uid = todos.length;//不知道干啥的
		  return todos;//返回todos
	},
	save: function (todos) {
		//把todos变成字符串，再存回Storage
		localStorage.setItem(STORAGE_KEY, JSON.stringify(todos));
	}
};
```
### todoStorage
todoStorage并不是单纯一个数组，而是用一个带有两个函数的对象  
- fetch函数  
  把todo从localStorage传进todos，并未每一个todo加上一个id和uid。**最后返回todos**
- save函数  
  把todos中的todo传回localStorage
### 接收todo
```html
<input 
	class="new-todo"
	placeholder="what needs to be done?"
	v-model="newTodo"
	@keyup.enter="addTodo"
>
```
- `placeholder`属性用来在输入框中放上个背景字
- 用`v-model`将输入的值双向的绑定到newTodo上  
  >```js
  >//newTodo在data中声明好，默认为空
  >data: {
  >  newTodo: ""
  >}
  >```
- vue提供`@keyup.enter`直接把提交事件绑定到回车上  
### 显示todo
用`v-for`提取filteredTodos中的todo  
注意：这里用的`<label>`标签作为todo的容器，但这里并没有与`<input>`关联，可能只是遵循了`<input><label>`要一起用的习惯
>filteredTodos是经过过滤的todos，过滤等后面在说
```html
<ul class="todo-list">
	<li 
		class="todo"
		v-for="todo in filteredTodos"
		:key="todo.id"
		:class="{ completed: todo.completed}"
   >
    <div>
      <input class="toggle" type="checkbox" v-model="todo.completed" />
      <label>{{ todo.title }}</label>
    </div>
   </li>
</ul>
```
## 功能2：切换已完成
用`v-model`绑定`CheckBox`的值和`todo.completed`，
```html
<!-- 用v-model直接绑定todo.completed -->
<input class="toggle" type="checkbox" v-model="todo.completed">
```
而`todo.completed`又绑定在`<li>`的`class`上
```html
<li :class="{ completed: todo.completed}"></li>
```
这样，就可以通过勾选`checkbox`来显示是否显示对应的todo  
还有切换全部为已完成  
```html
<input
  id="toggle-all"
  class="toggle-all"
  type="checkbox"
  v-model="allDone"
/>
```
这里`v-model`绑定的是计算属性`allDone`
```js
allDone: {
  get: function() {//getter回调函数 当需要读取当前属性值时执行
    return this.remaining === 0;
    //把remaining设为0,注意这里是三个等号即严格相等
    //即remaining等于0时返回true，checkbox被勾选
    //remaining不等于0时返回false，checkbox不被勾选
  },
  set: function(value) {//setter,监视当前属性值的变化，当属性值发生变化时执行
    this.todos.forEach(function(todo) {
      todo.completed = value;//把所有的todo的completed改成绑定的checkbox的值
    });
  }
}
```
## 功能3：删除todo
给`<button>`绑定`removeTodo`事件
```html
<button class="destroy" @click="removeTodo(todo)"></button>
```
直接把整个todo传进来，再用`indexOf()`加`splice()`删除
```js
removeTodo: function(todo) {
  this.todos.splice(this.todos.indexOf(todo), 1);
}
```
## 功能4：过滤
### filters
首先创建了一个filters对象，里面有三个函数，分别对应三个状态All,Actived,Completed  
这里过滤的并不是todo本身，而是todo的可见性，即`todo.completed`  
使用的是`filter()`函数，`filter()`函数不会改变原数组，会传回一个新数组，所以原数组不会被覆盖，可以反复使用
```js
// visibility filters
var filters = {
  all: function(todos) {
    return todos;
  },
  active: function(todos) {
    return todos.filter(function(todo) {
      return !todo.completed;//返回所有todo.completed为false的todo
    });
  },
  completed: function(todos) {
    return todos.filter(function(todo) {
      return todo.completed;//返回所有todo.completed为true的todo
    });
  }
};
```
### html
```html
<ul class="filters">
  <li>
    <a href="#/all" :class="{ selected: visibility == 'all' }">All</a>
  </li>
  <li>
    <a href="#/active" :class="{ selected: visibility == 'active' }">Active</a>
  </li>
  <li>
    <a href="#/completed" :class="{ selected: visibility == 'completed' }">Completed</a>
  </li>
</ul>
```
先看`href`属性，`href="#/all`的意思是：点记这个a标签后，网页的地址会在后面加上个#/all  
>http://127.0.0.1:5500/learn/TodoMVC/02/02.html#/active  

这样每当点击各个选项，网页的地址就会发生相应的变化。我们只需要侦听到这个变化就行了  
```js
function onHashChange() {
	//hash拿到了#/completed,再用replace加正则把#/去掉，剩下completed
	var visibility = window.location.hash.replace(/#\/?/, "")
	if(filters[visibility]) {
		app.visibility = visibility;
	}else{
		window.location.hash = "";
		app.visibility = "all"
	}
}
//当hashchange事件触发时，执行onHashChange
window.addEventListener("hashchange", onHashChange);
//先执行一次
onHashChange();
```
>`app.visibility`已在data中声明，默认为"all"  

这样就可以根据所点击的按钮，改变对应todo的visibility属性。再根据每个todo的visibility属性过滤todo
```js
filteredTodos: function() {
  //通过this.visibility可以拿到filters中相对应的方法
  return filters[this.visibility](this.todos);
},
```
在功能1：添加todo中已经提到，添加todo是从filteredTodos中添加的。所以这样就解决的过滤的功能
## 功能5：剩余未完成
剩余未完成同样用的是计算属性
```js
remaining: function() {
  return filters.active(this.todos).length;
}
```
这样就得到了剩余未完成的数量
```html
<strong>{{ remaining }}</strong> {{ remaining | pluralize }} left
```
但还有个问题就是后面的字，* item left  
如果前面的数字是多个，item就要加个s，变成items（用中文不就得了）所以这里要用到过滤器
```js
filters: {
  pluralize: function(n) {
    return n === 1 ? "item" : "items";
  }
}
```
使用过滤器的语法就是在双花括号中写在被过滤的东西后面，中间加个“|”。然后被过滤的东西会被传入过滤器，所以过滤器需要接收一个值